#!/bin/sh

# scrippies/ros-buildpackage

set -euvx

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}"
    return "${status}"
}

usage() {
    echo
}

# take nothing and detect the installed ros_distro; print ros_distro on
# success; print nothing on failure
detect_ros_distro() {
    if ! [ -d /opt/ros ]; then
        error "missing directory: /opt/ros"
        return 1
    fi
    local ros_distro_list="$(mktemp -t ros.distro.list.XXXXXX)"
    find /opt/ros -maxdepth 1 -mindepth 1 -type d -exec basename {} \; >"${ros_distro_list}"
    case "$(wc -l <"${ros_distro_list}")" in
        0)
            error "missing ROS installation"
            return 1
            ;;
        1)
            cat "${ros_distro_list}"
            return 0
            ;;
        *)
            error "multiple ROS installations"
            return 1
            ;;
    esac
}

# take distribution and use it to infer ros_distro; print ros_distro on
# success; print nothing on failure
infer_ros_distro() {
    case "$1" in
        xenial)
            echo "kinetic"
            return 0
            ;;
        bionic)
            echo "melodic"
            return 0
            ;;
        *)
            break
            ;;
    esac
    error "unknown distribution: $1"
    return 1
}

# * it must only consist of alphanumerics and _ separators. Other symbols might
#   not be supported by some OSes (e.g. unicode characters) or would make it
#   hard to follow OSes conventions
#
# * they must be at least two characters long and must start with an alphabetic
#   character. This rule is simply to force the name of the package to be more
#   human understandable.
#
# -- http://www.ros.org/reps/rep-0144.html#mandatory-rules
#
# ..._*BUT*_ catkin will happily build packages with hyphens, too.
vet_package_name() {
    echo "$1" | grep -Eo '^[a-z0-9][a-z0-9.+-]+$'
}

infer_package_name() {
    vet_package_name "$(basename "$1" | grep -Eo '^[^_]+')"
}

read_into() {
    mkdir -vp "$(dirname "$1")"
    cat >"$1"
}

detect_os_id() {
    if ! [ -f /etc/os-release ]; then
        error "missing file: /etc/os-release"
        return 1
    fi
    . /etc/os-release
    if ! [ -n "${ID:-}" ]; then
        error "undefined ID"
        return 1
    fi
    echo "${ID}"
}

detect_distribution() {
    if ! [ -f /etc/os-release ]; then
        error "missing file: /etc/os-release"
        return 1
    fi
    . /etc/os-release
    if ! [ -n "${VERSION_CODENAME:-}" ]; then
        error "undefined VERSION_CODENAME"
        return 1
    fi
    echo "${VERSION_CODENAME}"
}

generate_debian_control() {
    if [ -n "${DEBFULLNAME:-}" ]; then
        info "DEBFULLNAME: ${DEBFULLNAME}"
    else
        error "undefined: DEBFULLNAME"
        return 1
    fi

    if [ -n "${DEBEMAIL:-}" ]; then
        info "DEBEMAIL: ${DEBEMAIL}"
    else
        error "undefined: DEBEMAIL"
        return 1
    fi

    local package_name=""
    if package_name="$(infer_package_name "${PWD}")"; then
        info "inferred package_name: ${package_name}"
    else
        error "FAILURE: infer_package_name ${PWD}"
        return 1
    fi

    local os_id=""
    if os_id="$(detect_os_id)"; then
        info "detected os_id: ${os_id}"
    else
        error "FAILURE: detect_os_id"
        return 1
    fi

    local distribution=""
    if distribution="$(detect_distribution)"; then
        info "detected distribution: ${distribution}"
    else
        error "FAILURE: detect_distribution"
        return 1
    fi

    local ros_distro=""
    if ros_distro="$(detect_ros_distro)"; then
        info "detected ros_distro: ${ros_distro}"
    elif ros_distro="$(infer_ros_distro "${distribution}")"; then
        info "inferred ros_distro: ${ros_distro}"
    else
        error "failed to detect and/or infer ros_distro"
        return 1
    fi

    local install_cmds="$(mktemp -t install_cmds.XXXXXX)"
    rosdep install \
        --ignore-packages-from-source \
        --simulate \
        --reinstall \
        --os "${os_id}":"${distribution}" \
        --rosdistro "${ros_distro}" \
        --from-paths "${PWD}/src" \
        >"${install_cmds}"

    local deps="$(mktemp -t deps.XXXXXX)"
    awk '/^  sudo -H apt-get install /{print $NF}' <"${install_cmds}" >"${deps}"

    read_into "$1" <<EOF
Source: ${package_name}
Maintainer: ${DEBFULLNAME:-} <${DEBEMAIL:-}>
Section: devel
Priority: extra
Standards-Version: 3.9.6
Build-Depends: cmake, debhelper, dh-systemd, python-catkin-tools, $(paste -sd, <${deps})

Package: ${package_name}
Architecture: $(dpkg --print-architecture)
Depends: cmake, debhelper, dh-systemd, python-catkin-tools, $(paste -sd, <${deps})
Description: The ${package_name} package.
EOF
}

generate_debian_changelog() {
    local distribution=""
    if distribution="$(detect_distribution)"; then
        info "detected distribution: ${distribution}"
    else
        error "FAILURE: detect_distribution"
        return 1
    fi
    local package_name=""
    if package_name="$(infer_package_name "${PWD}")"; then
        info "inferred package_name: ${package_name}"
    else
        error "FAILURE: infer_package_name ${PWD}"
        return 1
    fi
    local version="$(basename ${PWD} | cut -d_ -f2-)"
    info "inferred version: ${version}"
    local issue_net="$(tr -dc '[:alnum:]' </etc/issue.net | tr '[:upper:]' '[:lower:]')"
    dch \
        --changelog "$1" \
        --create \
        --controlmaint \
        --distribution "${distribution}" \
        --package "${package_name}" \
        --newversion "${version}-${issue_net}" \
        "automated build"
}

generate_debian_rules() {
    read_into "$1" <<'EOF'
#!/usr/bin/make -f

PACKAGE = $(firstword $(shell dh_listpackages))
INSTALLATION_PREFIX = $(shell find /opt/ros -maxdepth 1 -mindepth 1 -type d | sort | head -1)
# ROS_DISTRO = $(shell basename $(INSTALLATION_PREFIX))

# There is something up with the Xenial debhelper. It uses gcc and g++
# even though cc and c++ are pointing to clang and clang++
export CXX=$(shell sh -c "command -v c++")
export CC=$(shell sh -c "command -v cc")

# Uncomment this to turn on verbose mode.
export DH_VERBOSE=1
# TODO: remove the LDFLAGS override.  It's here to avoid esoteric problems
# of this sort:
#  https://code.ros.org/trac/ros/ticket/2977
#  https://code.ros.org/trac/ros/ticket/3842
export LDFLAGS=
export PKG_CONFIG_PATH=$(INSTALLATION_PREFIX)/lib/pkgconfig
# Explicitly enable -DNDEBUG, see:
# 	https://github.com/ros-infrastructure/bloom/issues/327
export DEB_CXXFLAGS_MAINT_APPEND=-DNDEBUG

# because "make: write error: stdout" on parallel builds
# https://bugs.launchpad.net/ubuntu/+source/linux-signed/+bug/1814393
export MAKEFLAGS=--output-sync=line
export TERM=dumb


%:
	dh $@ -v --buildsystem=cmake --parallel --with systemd

override_dh_auto_configure:
	# In case we're installing to a non-standard location, look for a setup.sh
	# in the install tree that was dropped by catkin, and source it.  It will
	# set things like CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
	if [ -f "$(INSTALLATION_PREFIX)/setup.sh" ]; then . "$(INSTALLATION_PREFIX)/setup.sh"; fi && \
	dh_auto_configure -- \
		-DCATKIN_BUILD_BINARY_PACKAGE="1" \
		-DCMAKE_VERBOSE_MAKEFILE=true \
		-DCMAKE_INSTALL_PREFIX="$(INSTALLATION_PREFIX)" \
		-DCMAKE_PREFIX_PATH="$(INSTALLATION_PREFIX)"

override_dh_auto_build:
	# In case we're installing to a non-standard location, look for a setup.sh
	# in the install tree that was dropped by catkin, and source it.  It will
	# set things like CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
	if [ -f "$(INSTALLATION_PREFIX)/setup.sh" ]; then . "$(INSTALLATION_PREFIX)/setup.sh"; fi && \
	dh_auto_build

override_dh_auto_test:
	# In case we're installing to a non-standard location, look for a setup.sh
	# in the install tree that was dropped by catkin, and source it.  It will
	# set things like CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
	echo -- Running tests. Even if one of them fails the build is not canceled.
	if [ -f "$(INSTALLATION_PREFIX)/setup.sh" ]; then . "$(INSTALLATION_PREFIX)/setup.sh"; fi && \
	dh_auto_test || true

override_dh_shlibdeps:
	# In case we're installing to a non-standard location, look for a setup.sh
	# in the install tree that was dropped by catkin, and source it.  It will
	# set things like CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
	if [ -f "$(INSTALLATION_PREFIX)/setup.sh" ]; then . "$(INSTALLATION_PREFIX)/setup.sh"; fi && \
	dh_shlibdeps -l$(CURDIR)/debian/$(PACKAGE)/$(INSTALLATION_PREFIX)/lib/

override_dh_auto_install:
	# In case we're installing to a non-standard location, look for a setup.sh
	# in the install tree that was dropped by catkin, and source it.  It will
	# set things like CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
	if [ -f "$(INSTALLATION_PREFIX)/setup.sh" ]; then . "$(INSTALLATION_PREFIX)/setup.sh"; fi && \
	dh_auto_install
EOF
    chmod +x "$1"
}

generate_debian_compat() {
    read_into "$1" <<'EOF'
9   
EOF
}

generate_debian_source_format() {
    read_into "$1" <<'EOF'
3.0 (native)
EOF
}

generate_top_cmake() {
    local distribution=""
    if distribution="$(detect_distribution)"; then
        info "detected distribution: ${distribution}"
    else
        error "FAILURE: detect_distribution"
        return 1
    fi
    local ros_distro=""
    if ros_distro="$(detect_ros_distro)"; then
        info "detected ros_distro: ${ros_distro}"
    elif ros_distro="$(infer_ros_distro "${distribution}")"; then
        info "inferred ros_distro: ${ros_distro}"
    else
        error "failed to detect and/or infer ros_distro"
        return 1
    fi
    (
        set +euvx
        . "/opt/ros/${ros_distro}/setup.sh"
        catkin_init_workspace "${PWD}"
    )
    test -L "$1"
    # > -i[SUFFIX], --in-place[=SUFFIX]
    #
    # > edit files in place (makes backup if extension supplied). The default
    # > operation mode is to break symbolic and hard links. This can be changed
    # > with --follow-symlinks and --copy.
    #
    # https://linux.die.net/man/1/sed
    sed -i '' "$1"
    ! test -L "$1"
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

if [ -f "${PWD}/debian/control" ]; then
    info "found file: ${PWD}/debian/control"
else
    generate_debian_control "${PWD}/debian/control"
    warning "generated file: ${PWD}/debian/control"
fi

if [ -f "${PWD}/debian/changelog" ]; then
    info "found file: ${PWD}/debian/changelog"
else
    generate_debian_changelog "${PWD}/debian/changelog"
    warning "generated file: ${PWD}/debian/changelog"
fi

if [ -f "${PWD}/debian/rules" ]; then
    info "found file: ${PWD}/debian/rules"
else
    generate_debian_rules "${PWD}/debian/rules"
    warning "generated file: ${PWD}/debian/rules"
fi

if [ -f "${PWD}/debian/compat" ]; then
    info "found file: ${PWD}/debian/compat"
else
    generate_debian_compat "${PWD}/debian/compat"
    warning "generated file: ${PWD}/debian/compat"
fi

if [ -f "${PWD}/debian/source/format" ]; then
    info "found file: ${PWD}/debian/source/format"
else
    generate_debian_source_format "${PWD}/debian/source/format"
    warning "generated file: ${PWD}/debian/source/format"
fi

if [ -f "${PWD}/CMakeLists.txt" ]; then
    info "found file: ${PWD}/CMakeLists.txt"
else
    generate_top_cmake "${PWD}/CMakeLists.txt"
    warning "generated file: ${PWD}/CMakeLists.txt"
fi

dpkg-buildpackage $@

exit "$?"
