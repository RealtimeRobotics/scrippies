#!/bin/sh

# scrippies/docker-catkin

set -euvx

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly default_distribution="xenial"
readonly default_ros_distro="kinetic"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    local status="$?"
    rm -rf "${tmpdir}"
    if command -v docker >/dev/null 2>&1; then
        docker system prune --force --filter until=6h >&2 || true
    fi
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $0 [OPTION]...
Dockerize catkin build, catkin run_tests, and catkin_test_results.

Options:

    -h                 print usage and exit
    -C CATKIN_WS       run as if started in CATKIN_WS (default: \$PWD)
    -D DISTRIBUTION    ubuntu distribution (default: ${default_distribution})
    -R ROS_DISTRO      ros distribution (default: ${default_ros_distro})

Examples:

    \$ $0

    \$ $0 -C \$HOME/catkin_ws

    \$ $0 -C \$HOME/catkin_ws -D ${default_distribution}

    \$ $0 -C \$HOME/catkin_ws -D ${default_distribution} -R ${default_ros_distro}

EOF
}

infer_distribution() {
    local result=""
    case "$1" in
        kinetic)
            echo "xenial"
            return 0
            ;;
        melodic)
            echo "bionic"
            return 0
            ;;
        *) ;;

    esac
    error "unknown ros_distro: $1"
    return 1
}

infer_ros_distro() {
    case "$1" in
        xenial)
            echo "kinetic"
            return 0
            ;;
        bionic)
            echo "melodic"
            return 0
            ;;
        *) ;;
    esac
    error "unknown distribution: $1"
    return 1
}

# Print a sha1 for the current state of the checkout.
#
# When there are uncommitted changes, `git stash create` will make a commit
# object (without storing it) and print it. When there are no uncommitted
# changes, `git stash create` will print an empty string and succeed; in this
# case we want get sha1sum of the HEAD. We attempt to print both, but take only
# the first.
#
# $1 : git checkout directory
get_vcs_ref() {
    (
        git -C "$1" stash create
        git -C "$1" rev-parse HEAD
    ) | head -1
}

# Copy given git checkout directory into optional destination directory using
# `git archive`.
#
# reference:
# https://git-scm.com/docs/git-submodule#git-submodule-foreach--recursiveltcommandgt
#
# $1 : git checkout directory
# $2 : target directory (default: $PWD)
gitcopy() {
    git -C "$1" archive "$(get_vcs_ref "$1")" \
        | tar -C "${2:-${PWD}}" -xf-
    git -C "$1" submodule foreach --recursive --quiet \
        "git archive --prefix=\${sm_path}/ \${sha1} | tar -C ${2:-${PWD}} -xf-"
}

ttcopy() {
    tar -C "$1" -cf- . | tar -C "${2:-${PWD}}" -xf-
}

# Copy given source directory contents into optional destination directory. If
# `git` is present and source directory is a git checkout, then use `gitcopy`;
# else use `ttcopy`.
#
# $1 : source directory
# $2 : target directory (default: $PWD)
dircopy() {
    if command -v git >/dev/null 2>&1; then
        if git -C "$1" status >/dev/null 2>&1; then
            gitcopy "$1" "${2:-${PWD}}"
            return "$?"
        fi
    fi
    ttcopy "$1" "${2:-${PWD}}"
}

# takes a source directory and a target directory; operates on the catkin
# workspace currently residing at target directory; mutates files therein to
# change source references to target references.
#
# $1 : source directory
# $2 : target directory
catkin_ws_pathfix() {
    local source_dir="$1"
    local target_dir="$2"
    find \
        "${target_dir}/.catkin_tools" \
        "${target_dir}/build" \
        "${target_dir}/devel" \
        "${target_dir}/install" \
        "${target_dir}/logs" \
        -type f \
        -exec grep -qI "${source_dir}" {} + \
        -exec sed -i "s|${source_dir}|${target_dir}|g" {} + \
        || true
}

# https://stackoverflow.com/questions/23513045/how-to-check-if-a-process-is-running-inside-docker-container
# https://stackoverflow.com/questions/20010199/how-to-determine-if-a-process-runs-inside-lxc-docker
is_in_container() { grep -q 'lxc\|docker' /proc/1/cgroup; }

catkin_verb() {
    catkin $@ \
        --no-color \
        --no-notify \
        --no-status \
        --summarize \
        --verbose \
        --cmake-args \
        -DCMAKE_CPP_FLAGS="${CPPFLAGS:-}" \
        -DCMAKE_CXX_COMPILER="${CXX:-$(command -v c++)}" \
        -DCMAKE_CXX_FLAGS="${CXXFLAGS:-}" \
        -DCMAKE_C_COMPILER="${CC:-$(command -v cc)}" \
        -DCMAKE_C_FLAGS="${CFLAGS:-}" \
        -DCMAKE_VERBOSE_MAKEFILE=true \
        -- \
        --make-args \
        "${MAKEFLAGS:- --jobs=$((1 + $(nproc) >> 1)) --load-average=$(nproc)}" \
        --
}

# $1 : catkin_ws
#
# take catkin_ws and vet it; for good catkin_ws, print it and return success;
# otherwise, print nothing and return failure
vet_catkin_ws() {
    local result=""
    if ! result="$(readlink -f "$1")"; then
        error "bad path: $1"
        return 1
    fi
    if ! [ -d "${result}" ]; then
        error "not a directory: ${result}"
        return 1
    fi
    if ! [ -d "${result}/src" ]; then
        error "not a directory: ${result}/src"
        return 1
    fi
    echo "${result}"
    return 0
}

vet_root_script() {
    local result=""
    if ! result="$(readlink -f "$1")"; then
        error "bad path: $1"
        return 1
    fi
    if ! [ -x "${result}" ]; then
        warning "not executable: ${result}"
        if ! chmod -v +x "${result}" >&2; then
            error "FAILURE: chmod -v +x ${result}"
            return 1
        fi
    fi
    echo "${result}"
    return 0
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hC:D:R:" opt; do
    case "${opt}" in
        h)
            usage
            exit 0
            ;;
        C)
            if ! catkin_ws="$(vet_catkin_ws "${OPTARG}")"; then
                die "FAILURE: vet_catkin_ws ${OPTARG}"
            fi
            readonly catkin_ws="${catkin_ws}"
            ;;
        D) readonly distribution="${OPTARG}" ;;
        R) readonly ros_distro="${OPTARG}" ;;
        :) die "missing argument: -${OPTARG}" ;;
        \?) die "bad option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

# distribution
if [ -n "${distribution:-}" ]; then
    info "distribution: ${distribution}"
elif [ -n "${ros_distro:-}" ]; then
    if ! distribution="$(infer_distribution "${ros_distro}")"; then
        die "FAILURE: infer_distribution ${ros_distro}"
    fi
    readonly distribution="${distribution}"
    warning "inferred distribution: ${distribution}"
else
    readonly distribution="${default_distribution}"
    warning "defaulted distribution: ${distribution}"
fi

# ros_distro
if [ -n "${ros_distro:-}" ]; then
    info "ros_distro: ${ros_distro}"
elif [ -n "${distribution:-}" ]; then
    if ! ros_distro="$(infer_ros_distro "${distribution}")"; then
        die "FAILURE: infer_ros_distro ${distribution}"
    fi
    readonly ros_distro="${ros_distro}"
    warning "inferred ros_distro: ${ros_distro}"
else
    readonly ros_distro="${default_ros_distro}"
    warning "defaulted ros_distro: ${ros_distro}"
fi

# catkin_ws
if [ -n "${catkin_ws:-}" ]; then
    info "catkin_ws: ${catkin_ws}"
else
    if ! catkin_ws="$(vet_catkin_ws "${PWD}")"; then
        die "failure: vet_catkin_ws ${PWD}"
    fi
    readonly catkin_ws="${catkin_ws}"
    warning "defaulting catkin_ws: ${catkin_ws}"
fi

readonly copy_catkin_ws="$(mktemp -dt copy_catkin_ws.XXXXXX)"
dircopy "${catkin_ws}" "${copy_catkin_ws}"

# https://stackoverflow.com/questions/23513045/how-to-check-if-a-process-is-running-inside-docker-container
# https://stackoverflow.com/questions/20010199/how-to-determine-if-a-process-runs-inside-lxc-docker
if ! is_in_container; then
    # We build stuff under $TMPDIR. Sometimes, the build requires the
    # extraction of tarballs. Extracting tarballs on OverlayFS is, apparently,
    # full of fail (https://github.com/moby/moby/issues/19647). This is
    # especially problematic because the default backing store for docker is
    # OverlayFS.
    #
    # To get around the OverlayFS issue, we need to bind-mount the host $TMPDIR
    # to the container $TMPDIR. To isolate the current build from others like
    # it, we first override $TMPDIR to a location specific to the current
    # build.
    #
    # Also, there's a prevailing assumption that source will be built within
    # the home directory of the user executing the build. To satisfy this
    # assumption within the container, we create a luser with HOME=$TMPDIR .
    readonly image_name="registry.gitlab.com/realtime-robotics/ros-dpkg:${ros_distro}"
    if [ "true" = "${DOCKER_IMAGE_PULL:-false}" ] \
        || ! docker image inspect "${image_name}" >/dev/null 2>&1; then
        docker image pull "${image_name}"
    else
        warning "skipping: docker image pull ${image_name}"
    fi
    docker image inspect "${image_name}"

    readonly docker_workdir="$(mktemp -ut docker_workdir.XXXXXX)"
    docker container run \
        --env COPY_CATKIN_WS="${copy_catkin_ws}" \
        --env DEBCONF_NONINTERACTIVE_SEEN=true \
        --env DEBIAN_FRONTEND=noninteractive \
        --env DISTRIBUTION="${distribution}" \
        --env DOCKER_HOST_GID="$(id -g)" \
        --env DOCKER_HOST_UID="$(id -u)" \
        --env HERE="${here}" \
        --env ROS_DISTRO="${ros_distro}" \
        --env SUDO_FORCE_REMOVE=yes \
        --env THIS="${this}" \
        --interactive \
        --mount type=bind,readonly,source="${copy_catkin_ws}",target="${copy_catkin_ws}" \
        --mount type=bind,readonly,source="${here}",target="${here}" \
        --mount type=bind,source="${PWD}",target="${docker_workdir}" \
        --rm \
        --workdir "${docker_workdir}" \
        "${image_name}" sh <<'EOF'
set -euvx

# maybe someday:
#dpkg-divert --local --rename /bin/bash

dpkg-divert --local --rename /usr/bin/git

${HERE}/configure-apt
apt-get -y update

groupadd -g "${DOCKER_HOST_GID}" luser
useradd \
    --create-home \
    --uid "${DOCKER_HOST_UID}" \
    --gid "${DOCKER_HOST_GID}" \
    --shell "$(command -v sh)" \
    luser

# STUPID ROS: rosdep invokes sudo apt-get to install things
apt-get -y --no-install-recommends install sudo
cat >/etc/sudoers.d/luser-apt-get <<LUSER_APT_GET
luser $(hostname) = (root) NOPASSWD: $(command -v apt-get)
LUSER_APT_GET

nice -n19 su luser <<'SU_LUSER'
set -euvx
rosdep update --verbose
# http://wiki.ros.org/rosdep#Install_dependency_of_all_packages_in_the_workspace
rosdep install \
    --default-yes \
    --from-path "${COPY_CATKIN_WS}/src" \
    --ignore-packages-from-source \
    --verbose \
    && true
SU_LUSER

# STUPID ROS: now de-sudo luser and uninstall sudo
rm -vf /etc/sudoers.d/luser-apt-get

# STUPID ROS: this used to be okay, then something with catkin happened
# -- neil 2019.10.28
if false; then
    apt-get -y purge sudo
    apt-get -y autoremove
fi

# because pcl_ros has too many shared objects
pclros_config_cmake="/opt/ros/${ROS_DISTRO}/share/pcl_ros/cmake/pcl_rosConfig.cmake"
if [ -f "${pclros_config_cmake}" ]; then
    sed -r \
        -i.backup \
        -e 's,;/usr/include/vtk[[:alnum:].-]+,,g' \
        -e 's,;/usr/lib(/x86_64-linux-gnu)?/libvtk[[:alnum:].-]+,,g' \
        "${pclros_config_cmake}"
    ! diff "${pclros_config_cmake}.backup" "${pclros_config_cmake}"
fi

# because gnu tar hates OverlayFS2
if cmd_tar="$(command -v tar)"; then
    if cmd_bsdtar="$(command -v bsdtar)"; then
        dpkg-divert --local --rename "${cmd_tar}"
        ln -vsf "${cmd_bsdtar}" "${cmd_tar}"
    fi
fi

if command -v npm; then
    "${HERE}/configure-npm"
fi

nice -n19 su luser <<'SU_LUSER'
set -euvx
${THIS} -C ${COPY_CATKIN_WS} -D ${DISTRIBUTION} -R ${ROS_DISTRO}
SU_LUSER

EOF

    # hold off on this for now
    if false; then
        catkin_ws_pathfix "${docker_workdir}" "${PWD}"
    fi

    exit "$?"
fi

env | sort

catkin init --workspace "${copy_catkin_ws}"
catkin config --workspace "${copy_catkin_ws}" --extend "/opt/ros/${ros_distro}" --install
catkin clean --workspace "${copy_catkin_ws}" --yes
catkin_verb build --workspace "${copy_catkin_ws}"
catkin_verb run_tests --workspace "${copy_catkin_ws}"
result=""
(
    # because ROS stupidly expands undefined variables, but we still need to
    # collect test results failures
    set +eu
    . "/opt/ros/${ros_distro}/setup.sh"
    catkin_test_results "${copy_catkin_ws}"
) && result="$?" || result="$?"

symlinks -cdrs "${copy_catkin_ws}"

ttcopy "${copy_catkin_ws}" "${PWD}"

# hold off on this for now
if false; then
    catkin_ws_pathfix "${copy_catkin_ws}" "${PWD}"
fi

exit "${result}"
