#!/bin/sh

# scrippies/git2origtar

set -eu

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}" || true
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]...
From a git checkout, create an orig tarball and print its path.

Options
    -h            print this usage and return success
    -C WORKDIR    run as if started in WORKDIR (default: \$PWD)
    -o OUTFILE    write to OUTFILE (default: \$PWD/\$(basename \$WORKDIR)_\$(git -C \$WORKDIR describe --long --always).orig.tar)

Examples:

    \$ $0

    \$ $0 -C ~/code/rapidplan

    \$ $0 -C ~/code/rapidplan -o rapidplan.orig.tar

EOF
}

# Print a sha1 for the current state of the checkout.
#
# When there are uncommitted changes, `git stash create` will make a commit
# object (without storing it) and print it. When there are no uncommitted
# changes, `git stash create` will print an empty string and succeed; in this
# case we want get sha1sum of the HEAD. We attempt to print both, but take only
# the first.
#
# $1 : git checkout directory
get_vcs_ref() {
    (
        git -C "$1" stash create
        git -C "$1" rev-parse HEAD
    ) | head -1
}

# Copy given git checkout directory into optional destination directory using
# `git archive`.
#
# reference:
# https://git-scm.com/docs/git-submodule#git-submodule-foreach--recursiveltcommandgt
#
# $1 : git checkout directory
# $2 : target directory (default: $PWD)
gitcopy() {
    git -C "$1" archive "$(get_vcs_ref "$1")" \
        | tar -C "${2:-${PWD}}" -xf-
    git -C "$1" submodule foreach --recursive --quiet \
        "git archive --prefix=\${sm_path}/ \${sha1} | tar -C ${2:-${PWD}} -xf-"
}

# > Package names (both source and binary, see Package) must consist only of
# > lower case letters (a-z), digits (0-9), plus (+) and minus (-) signs, and
# > periods (.). They must be at least two characters long and must start with
# > an alphanumeric character.
#
# --- https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-source
is_good_package_name() {
    echo $@ | grep -Eq '^[a-z0-9][a-z0-9.+-]+$'
}

is_good_version() {
    echo $@ | grep -Eq '^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+-[[:digit:]]+-g[[:xdigit:]]{7,40}$'
}

# $1 : workdir
infer_outfile() {
    local package_name="$(basename "$1")"
    if ! is_good_package_name "${package_name}"; then
        error "bad package_name: ${package_name}"
        return 1
    fi
    local version="$(git -C "$1" describe --long --always)"
    if ! is_good_version "${version}"; then
        if ! [ "true" = "${requested_force:-false}" ]; then
            error "bad version: ${version}"
            return 1
        fi
        warning "bad version: ${version}"
    fi
    echo "${PWD}/${package_name}_${version}.orig.tar"
    return 0
}

vet_workdir() {
    local result=""
    if ! result="$(readlink -f "$1")"; then
        error "bad path: $1"
        return 1
    fi
    if ! [ -d "${result}" ]; then
        error "missing directory: ${result}"
        return 1
    fi
    if ! [ "${result}" = "$(git -C "${result}" rev-parse --show-toplevel)" ]; then
        error "missing git dir: ${result}"
        return 1
    fi
    if ! [ "true" = "$(git -C "${result}" rev-parse --is-inside-work-tree)" ]; then
        error "is inside git work tree: ${result}"
        return 1
    fi
    echo "${result}"
    return 0
}

vet_outfile() {
    local result=""
    if ! result="$(readlink -f "$1")"; then
        error "bad path: $1"
        return 1
    fi
    if [ -f "${result}" ]; then
        if ! [ "true" = "${requested_force:-false}" ]; then
            error "exists: ${result}"
            return 1
        fi
        warning "extant file: ${result}"
        warning "$(rm -v "${result}")"
    fi
    echo "${result}"
    return 0
}

vet_mtime() {
    local result=""
    if ! result="@$(date -d "$1" +%s)"; then
        error "bad mtime: $1"
        return 1
    fi
    echo "${result}"
    return 0
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hfC:o:" opt; do
    case "${opt}" in
        h)
            usage
            exit "$?"
            ;;
        f) requested_force="true" ;;
        C) workdir="${OPTARG}" ;;
        o) outfile="${OPTARG}" ;;
        :) die "Missing argument: -${OPTARG}" ;;
        \?) die "Invalid option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

# workdir
if ! [ -n "${workdir:-}" ]; then
    workdir="${PWD}"
    warning "defaulted workdir: ${workdir}"
fi
if ! workdir="$(vet_workdir "${workdir}")"; then
    die "FAILURE: vet_workdir ${workdir}"
fi
readonly workdir="${workdir}"
info "workdir: ${workdir}"

# outfile
if ! [ -n "${outfile:-}" ]; then
    outfile="$(infer_outfile "${workdir}")"
    warning "inferred outfile: ${outfile}"
fi
if ! outfile="$(vet_outfile "${outfile}")"; then
    die "FAILURE: vet_outfile ${outfile}"
fi
readonly outfile="${outfile}"
info "outfile: ${outfile}"

# mtime
mtime="$(git -C "${workdir}" show -s --format=%ci HEAD)"
if ! mtime="$(vet_mtime "${mtime}")"; then
    die "FAILURE: vet_mtime ${mtime}"
fi
readonly mtime="${mtime}"
info "mtime: ${mtime} ($(date -uIs -d "${mtime}"))"

# ###############################################
# Explanation for a horrible little shell snippet
# ###############################################
#
# `sed 's/./\\&/g'`
#
# This is some shell trickery to deal with whitespace-containing filenames. The
# original belongs to Rich Felker, and it was good enough for me to steal when
# Makeself needed such a patch.
#
# * http://www.etalabs.net/sh_tricks.html
# * https://github.com/megastep/makeself/pull/153
#
#
# `--pax-option "exthdr.name=%d/PaxHeaders.0/%f"`
#
# If tar tries to write a pax header, then this option should keep the PID
# (which is not deterministic) out of the archive. The golang folks do this, so
# it seems like a generally good idea for any tar implementation, not just GNU.
#
# * https://groups.google.com/forum/#!msg/golang-dev/8mY37Lc-AsQ/xC2oVQ2iEwAJ
# * https://github.com/golang/go/issues/12358
#
#
# `--pax-option="delete=atime"`
# `--pax-option="delete=ctime"`
# `--pax-option="delete=mtime"`
# `--mtime=0`
#
# This is some sillyness to force both GNU tar v1.28 (xenial) and v1.29
# (bionic) to deterministically create identical archives; i.e., any two with
# identical content will have identical checksums. This turns out to be Really
# Difficult.
#
# Here, with the `--pax-option=delete=atime,delete=ctime,delete=mtime` options,
# I'm asking `tar` to keep timestamps out of the archive. For reasons that
# escape me, this is necessary to stop GNU tar v1.29 from writing the Pax
# Header. Conversely, GNU tar v1.28 seems happy to omit the Pax Header under
# all the conditions I tested.
#
# Note that I'm _also_ specifying `--mtime` which causes the given Unix
# Timestamp to be written into the archive as the modification time for all
# members. A sane person would expect `--mtime=...` and
# `--pax-option="delete=mtime"` to mutually conflict, so that should inform
# your opinion of the GNU tar developers.
#
# * https://www.gnu.org/software/tar/manual/tar.html#SEC147
(
    cd "$(mktemp -d)"
    gitcopy "${workdir}"
    find . ! -type d \
        | sort \
        | sed 's/./\\&/g' \
        | xargs tar \
            --numeric-owner \
            --owner=0 \
            --group=0 \
            --format=pax \
            --pax-option="exthdr.name=%d/PaxHeaders.0/%f" \
            --pax-option="delete=atime" \
            --pax-option="delete=ctime" \
            --pax-option="delete=mtime" \
            --mtime="${mtime}" \
            -rf "${outfile}"
)

echo "${outfile}"
exit "$?"
