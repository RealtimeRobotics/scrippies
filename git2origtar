#!/bin/sh

# scrippies/git2origtar

set -eu

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}" || true
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]...
From a git checkout, create an orig tarball and print its path.

Options
    -h            print this usage and return success
    -C WORKDIR    run as if started in WORKDIR (default: \$PWD)
    -o OUTFILE    write to OUTFILE (default: \$PWD/\$(basename \$WORKDIR)_\$(git -C \$WORKDIR describe --long --always).orig.tar)

Examples:

    \$ $0

    \$ $0 -C ~/code/rapidplan

    \$ $0 -C ~/code/rapidplan -o rapidplan.orig.tar

EOF
}

# Print a sha1 for the current state of the checkout.
#
# When there are uncommitted changes, `git stash create` will make a commit
# object (without storing it) and print it. When there are no uncommitted
# changes, `git stash create` will print an empty string and succeed; in this
# case we want get sha1sum of the HEAD. We attempt to print both, but take only
# the first.
#
# $1 : git checkout directory
get_vcs_ref() {
    (
        git -C "$1" stash create
        git -C "$1" rev-parse HEAD
    ) | head -1
}

# Copy given git checkout directory into optional destination directory using
# `git archive`.
#
# reference:
# https://git-scm.com/docs/git-submodule#git-submodule-foreach--recursiveltcommandgt
#
# $1 : git checkout directory
# $2 : target directory (default: $PWD)
gitcopy() {
    git -C "$1" archive "$(get_vcs_ref "$1")" \
        | tar -C "${2:-${PWD}}" -xf-
    git -C "$1" submodule foreach --recursive --quiet \
        "git archive --prefix=\${sm_path}/ \${sha1} | tar -C ${2:-${PWD}} -xf-"
}

# > Package names (both source and binary, see Package) must consist only of
# > lower case letters (a-z), digits (0-9), plus (+) and minus (-) signs, and
# > periods (.). They must be at least two characters long and must start with
# > an alphanumeric character.
#
# --- https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-source
is_good_package_name() {
    echo $@ | grep -Eq '^[a-z0-9][a-z0-9.+-]+$'
}

is_good_version() {
    echo $@ | grep -Eq '^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+-[[:digit:]]+-g[[:xdigit:]]{7,40}$'
}

# $1 : git checkout directory
get_default_outfile() {
    local package_name="$(basename "$1")"
    if ! is_good_package_name "${package_name}"; then
        error "bad package_name: ${package_name}"
        return 1
    fi
    local version="$(git -C "$1" describe --long --always)"
    if ! is_good_version "${version}"; then
        error "bad version: ${version}"
        return 1
    fi
    echo "${PWD}/${package_name}_${version}.orig.tar"
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hC:o:" opt; do
    case "${opt}" in
        h)
            usage
            exit "$?"
            ;;
        C)
            if ! workdir="$(readlink -f "${OPTARG}")"; then
                die "missing path: ${OPTARG}"
            fi
            if ! [ -d "${workdir}" ]; then
                die "missing directory: ${workdir}"
            fi
            readonly workdir="${workdir}"
            ;;
        o)
            if ! outfile="$(readlink -f "${OPTARG}")"; then
                die "missing path: ${OPTARG}"
            fi
            readonly outfile="${outfile}"
            ;;
        :) die "Missing argument: -${OPTARG}" ;;
        \?) die "Invalid option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

# workdir
if ! [ -n "${workdir:-}" ]; then
    readonly workdir="${PWD}"
    warning "defaulting workdir: ${workdir}"
fi
if ! git -C "${workdir}" rev-parse HEAD >/dev/null 2>&1; then
    die "not a git checkout: ${workdir}"
fi

# outfile
if ! [ -n "${outfile:-}" ]; then
    if ! outfile="$(get_default_outfile "${workdir}")"; then
        die "FAILURE: get_default_outfile ${workdir}"
    fi
    readonly outfile="${outfile}"
    warning "defaulting outfile: ${outfile}"
fi
if [ -f "${outfile}" ]; then
    warning "extant outfile: ${outfile}"
    warning "$(rm -v "${outfile}")"
fi

# unix time stamp for HEAD commit
readonly ts="$(git -C "${workdir}" show -s --format=%ct HEAD)"
(
    cd "$(mktemp -d)"
    gitcopy "${workdir}"

    # ###############################################
    # Explanation for a horrible little shell snippet
    # ###############################################
    #
    # `sed 's/./\\&/g'`
    #
    # This is some shell trickery to deal with whitespace-containing
    # filenames. The original belongs to Rich Felker, and it was good enough
    # for me to steal when Makeself needed such a patch.
    #
    # * http://www.etalabs.net/sh_tricks.html
    # * https://github.com/megastep/makeself/pull/153
    #
    #
    # `--pax-option "exthdr.name=%d/PaxHeaders.0/%f"`
    #
    # If tar tries to write a pax header, then this option should keep the PID
    # (which is not deterministic) out of the archive. The golang folks do
    # this, so it seems like a generally good idea for any tar implementation,
    # not just GNU.
    #
    # * https://groups.google.com/forum/#!msg/golang-dev/8mY37Lc-AsQ/xC2oVQ2iEwAJ
    # * https://github.com/golang/go/issues/12358
    #
    #
    # `--pax-option="delete=atime"`
    # `--pax-option="delete=ctime"`
    # `--pax-option="delete=mtime"`
    # `--mtime=0`
    #
    # This is some sillyness to force both GNU tar v1.28 (xenial) and v1.29
    # (bionic) to deterministically create identical archives; i.e., any two
    # with identical content will have identical checksums. This turns out to
    # be Really Difficult.
    #
    # Here, with the `--pax-option=delete=atime,delete=ctime,delete=mtime`
    # options, I'm asking `tar` to keep timestamps out of the archive. For
    # reasons that escape me, this is necessary to stop GNU tar v1.29 from
    # writing the Pax Header. Conversely, GNU tar v1.28 seems happy to omit the
    # Pax Header under all the conditions I tested.
    #
    # Note that I'm _also_ specifying `--mtime=@${ts}` which causes the given
    # Unix Timestamp to be written into the archive as the modification time
    # for all members. A sane person would expect `--mtime=...` and
    # `--pax-option="delete=mtime"` to mutually conflict, so that should inform
    # your opinion of the GNU tar developers.
    #
    # * https://www.gnu.org/software/tar/manual/tar.html#SEC147
    find . ! -type d \
        | sort \
        | sed 's/./\\&/g' \
        | xargs tar \
            --numeric-owner \
            --owner=0 \
            --group=0 \
            --format=pax \
            --pax-option="exthdr.name=%d/PaxHeaders.0/%f" \
            --pax-option="delete=atime" \
            --pax-option="delete=ctime" \
            --pax-option="delete=mtime" \
            --mtime=@"${ts}" \
            -rf "${outfile}"
)

echo "${outfile}"
