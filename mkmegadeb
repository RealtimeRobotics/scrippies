#!/bin/sh

# scrippies/mkmegadeb

set -eu

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${here}").$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly default_distribution="xenial"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}"
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]...
Create megadeb from all debian packages in current working directory.

Options:
    -h                 print this usage and return success
    -C WORKDIR         run as if started in WORKDIR
    -D DISTRIBUTION    override distribution (default: ${default_distribution})
    -R                 "repolize" WORKDIR before building (default: false)
    -o DEB_RUN         output to DEB_RUN (default: \$WORKDIR.deb.run)

Examples:

    \$ $(basename ${this})

    \$ $(basename ${this}) -C \$PWD

    \$ $(basename ${this}) -C \$PWD -D xenial

    \$ $(basename ${this}) -C \$PWD -D xenial -R

    \$ $(basename ${this}) -C \$PWD -D xenial -R -o \$PWD.deb.run

EOF
}

apt_config_path() {
    cut -d= -f2 | xargs -n1 | paste -sd/ | xargs readlink -f
}

etc_apt() {
    apt-config shell _ Dir _ Dir::Etc | apt_config_path
}

etc_apt_sources_list() {
    apt-config shell _ Dir _ Dir::Etc _ Dir::Etc::sourcelist | apt_config_path
}

etc_apt_sources_list_d() {
    apt-config shell _ Dir _ Dir::Etc _ Dir::Etc::sourceparts | apt_config_path
}

var_lib_apt_lists() {
    apt-config shell _ Dir _ Dir::State _ Dir::State::lists | apt_config_path
}

# create and export a fake apt environment in the given directory
#
# $1 : fake apt dir
enfake_apt() {
    local apt_subdirs_list="$(mktemp -t apt_subdirs_list.XXXXXX)"
    cat >"${apt_subdirs_list}" <<EOF
etc/apt
var/cache/apt
var/lib/apt
var/lib/dpkg
var/log/apt
EOF
    # we don't care when the following happens:
    #
    #     tar: var/cache/apt/archives/partial: Cannot open: Permission denied
    #     tar: var/cache/apt/archives/lock: Cannot open: Permission denied
    #     tar: var/lib/apt/lists/partial: Cannot open: Permission denied
    #     tar: var/lib/apt/lists/lock: Cannot open: Permission denied
    #     tar: var/lib/dpkg/lock-frontend: Cannot open: Permission denied
    #     tar: var/lib/dpkg/triggers/Lock: Cannot open: Permission denied
    #     tar: var/lib/dpkg/lock: Cannot open: Permission denied
    #     tar: Exiting with failure status due to previous errors
    xargs tar -cf- -C / <"${apt_subdirs_list}" | tar -xf- -C "$1"
    (
        cd "$1"
        xargs mkdir -vp <"${apt_subdirs_list}"
    )
    export APT_CONFIG="$1/etc/apt/apt.conf"
    cat >"${APT_CONFIG}" <<EOF
Dir "$1";
EOF
}

run_megadeb() {
    env | sort
    # vet the archive directory
    if ! [ -f "${here}/Packages" ]; then
        error "missing file: ${here}/Packages"
        return 1
    fi

    info "creating temporary apt configuration"
    enfake_apt "$(mktemp -dt fake_apt_dir.XXXXXX)"

    # remove old apt sources list files
    find "$(etc_apt)" -type f -name '*.list' -print -delete
    find "$(var_lib_apt_lists)" -type f -print -delete

    # install new apt sources list file
    cat >"$(etc_apt_sources_list_d)/$(echo "${here}" | tr -s '/' '_').list" <<EOF
deb [trusted=yes] file://${here} ./
EOF

    # update apt to make it aware of the new fake repo
    apt-get -yqo APT::Sandbox::User="$(whoami)" update

    # if install-list.txt exists, then install those; else install everything
    info "installing packages"
    if [ -f "${here}/install-list.txt" ]; then
        cat "${here}/install-list.txt"
    else
        find "${here}" -maxdepth 1 -type f -name '*.deb' \
             -exec dpkg-deb --show --showformat='${Package}\n' {} \;
    fi | xargs apt-get \
        -yqo APT::Sandbox::User="$(whoami)" \
        --no-install-recommends \
        --verbose-versions \
        install
}

build_megadeb() {
    if [ "true" = "${repolize:-false}" ]; then
        "${here}/repolizer" -C "${workdir}" -D "${distribution}"
    fi

    # create and populate makeself archive dir
    readonly makeself_archive_dir="$(mktemp -dt makeself_archive_dir.XXXXXX)"
    tar -C "${workdir}" -cf- . | tar -C "${makeself_archive_dir}" -xf-
    cp -v "${this}" "${makeself_archive_dir}/$(basename "${this}")"

    if [ -n "${makeself_file_name:-}" ]; then
        info "makeself_file_name: ${makeself_file_name}"
    else
        readonly makeself_file_name="${workdir}.deb.run"
        warning "defaulting makeself_file_name: ${makeself_file_name}"
    fi

    # note the (undocumented) trailing `-r` option; this is what causes the
    # self-extracting archive to invoke this script's `run_megadeb` function
    "${here}/mkself" \
        --nocomp --sha256 \
        "${makeself_archive_dir}" \
        "${makeself_file_name}" \
        "MegaDeb" \
        "./$(basename "${this}")" -r
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C
export DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true

while getopts ":hrC:D:Ro:" opt; do
    case "${opt}" in
        h)
            usage
            exit 0
            ;;
        r) readonly run_megadeb="true" ;;
        C)
            if ! workdir="$(readlink -f "${OPTARG}")"; then
                die "missing: ${OPTARG}"
            fi
            if ! [ -d "${workdir}" ]; then
                die "not a directory: ${workdir}"
            fi
            readonly workdir="${workdir}"
            ;;
        D) readonly distribution="${OPTARG}" ;;
        R) readonly repolize="true" ;;
        o) readonly makeself_file_name="${OPTARG}" ;;
        :) die "missing argument: -${OPTARG}" ;;
        \?) die "bad option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

if ! [ 0 -eq "$#" ]; then
    die "bad args"
fi

if [ -n "${distribution:-}" ]; then
    info "distribution: ${distribution}"
else
    readonly distribution="${default_distribution}"
    warning "defaulting distribution: ${distribution}"
fi

if [ -n "${workdir:-}" ]; then
    info "workdir: ${workdir}"
else
    readonly workdir="${PWD}"
    warning "defaulting workdir: ${workdir}"
fi

if [ "true" = "${run_megadeb:-false}" ]; then
    run_megadeb
else
    build_megadeb
fi

exit "$?"
