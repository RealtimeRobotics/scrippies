#!/bin/sh

# scrippies/repolizer

set -euvx

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${here}").$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly default_distribution="xenial"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

#############################
# RE: SHELL KEYWORD `local` #
#############################
#
# > [variable scope limiting] is normally done with the local keyword, which is
# > ... not defined by POSIX.
#
# > However, even the most primitive POSIX-compliant shell I know of which is
# > used by some GNU/Linux distributions as the /bin/sh default, dash (Debian
# > Almquist Shell), supports it. FreeBSD and NetBSD use ash, the original
# > Almquist Shell, which also supports it. OpenBSD uses a ksh implementation
# > for /bin/sh which also supports it.
#
# https://stackoverflow.com/questions/18597697/posix-compliant-way-to-scope-variables-to-a-function-in-a-shell-script/18600920#18600920

############################
# RE: DEBIAN PACKAGE NAMES #
############################
#
# > Package names (both source and binary, see Package) must consist only
# > of lower case letters (a-z), digits (0-9), plus (+) and minus (-)
# > signs, and periods (.). They must be at least two characters long and
# > must start with an alphanumeric character.
#
# https://www.debian.org/doc/debian-policy/ch-controlfields.html#source

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    local status="$?"
    rm -rf "${tmpdir}"
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]...
Make current working directory an apt repository with resolved dependencies.

Options:
    -h                 print this usage and return success
    -C WORKDIR         run as if started in WORKDIR
    -D DISTRIBUTION    override distribution (default: ${default_distribution})

Examples:

    \$ $(basename ${this})

    \$ $(basename ${this}) -C \$PWD

    \$ $(basename ${this}) -C \$PWD -D xenial

EOF
}

# $1 : start node
# $2 : edge list
# $3 : result list
traverse() {
    # if $1 is already a result, then do nothing and return
    if grep -qE "^$1$" "$3"; then
        return
    fi

    # look for edges starting at $1: if none, then add $1 to results and return
    if [ -n "$(sed -nr "/^$1\t[[:graph:]]+$/p" "$2")" ]; then
        echo "$1" >>"$3"
        return
    fi

    # else, process each edge
    sed -nr "/^$1\t[[:graph:]]+$/p" "$2" | while read curr next; do
        traverse "${next}" "$2" "$3"
    done
}

# Kosaraju's algorithm for finding strongly connected components
#
# $1 : adjacency list of edges
kosaraju_scc() {
    # vet given edges file
    if ! [ -n "${1:-}" ]; then
        error "bad args"
        return 1
    fi
    if ! [ -f "$1" ]; then
        error "missing file: $1"
        return 1
    fi
    if ! [ -s "$1" ]; then
        error "empty file: $1"
        return 1
    fi
    local edges="$(mktemp -t edges.XXXXXX)"
    cp -v "$1" "${edges}"

    # create the topological sort; save stderr to find cycles
    tsort_out="$(mktemp -t tsort_out.XXXXXX)"
    tsort_err="$(mktemp -t tsort_err.XXXXXX)"
    if ! tsort <"${edges}" >"${tsort_out}" 2>"${tsort_err}"; then
        while read tsort_err_line; do
            warning "${tsort_err_line}"
        done <"${tsort_err}"
    fi

    # remove edges that comprise cycles
    sed -nr 's|^tsort: ([[:graph:]]+)$|\1|gp' "${tsort_err}" \
        | xargs -I{} sed -i "/^{}/d" "${edges}"

    # transpose edges to create reverse edges
    local redges="$(mktemp -t redges.XXXXXX)"
    sed -r 's|^([[:graph:]]+)([[:space:]]+)([[:graph:]]+)$|\3\2\1|g' <"${edges}" >"${redges}"

    # in topological order, traverse the graph of reversed edges; print every
    # dead end
    local dead_ends="$(mktemp -t dead_ends.XXXXXX)"
    while read pkg; do
        traverse "${pkg}" "${redges}" "${dead_ends}"
    done <"${tsort_out}"
    cat "${dead_ends}"
}

# take a Packages, print every "Package" field
packages2names() {
    sed -nr \
        's|^Package:[[:space:]]+([[:alnum:]][[:alnum:].+-]+).*$|\1|gp' \
        "${@:-/dev/stdin}"
}

# given Packages file, print dependency edges
#
# $1 : Packages file
packages2edges() {
    # vet given Packages file
    local packages_file="${1:-}"
    if ! [ -n "${packages_file}" ]; then
        error "bad args"
        return 1
    fi
    if ! [ -f "${packages_file}" ]; then
        error "missing file: ${packages_file}"
        return 1
    fi
    if ! [ -s "${packages_file}" ]; then
        error "empty file: ${packages_file}"
        return 1
    fi

    # enumerate package names (see above re: debian package names)
    local package_name_list="$(mktemp -t package_name_list.XXXXXX)"
    sed -nr 's|^Package:[[:space:]]+([[:alnum:]][[:alnum:].+-]+).*$|\1|gp' \
        <"${packages_file}" >"${package_name_list}"
    if ! [ -s "${package_name_list}" ]; then
        error "empty file: ${package_name_list}"
        return 1
    fi

    # enumerate recursive dependencies
    # https://stackoverflow.com/questions/22008193/how-to-list-download-the-recursive-dependencies-of-a-debian-package/41428445#41428445
    local apt_cache_depends="$(mktemp -t apt_cache_depends.XXXXXX)"
    xargs apt-cache depends \
        --recurse \
        --no-recommends \
        --no-suggests \
        --no-conflicts \
        --no-breaks \
        --no-replaces \
        --no-enhances \
        --no-pre-depends \
        <"${package_name_list}" >"${apt_cache_depends}"

    # From the `apt-cache depends` output, create the "depends blocks"
    # file of the following form:
    #
    #     <PKG-1>
    #     <DEP-1-1>
    #
    #     <PKG-2>
    #
    #     <PKG-3>
    #     <DEP-3-1>
    #     <DEP-3-2>
    #     ...
    local depends_blocks="$(mktemp -t depends_blocks.XXXXXX)"
    sed -nr \
        -e 's/^([[:alnum:]][[:alnum:].+-]+)$/\n\1/gp' \
        -e 's/^ [ |]Depends: ([[:alnum:]][[:alnum:].+-]+)$/\1/gp' \
        <"${apt_cache_depends}" >"${depends_blocks}"

    # From the depends blocks, create the adjacency list of the following form:
    #
    #     <PKG-1>\t<DEP-1-1>
    #     <PKG-2>
    #     <PKG-3>\t<DEP-3-1>\t<DEP-3-2>
    #     ...
    local adjlist="$(mktemp -t adjlist.XXXXXX)"
    (
        cd "$(mktemp -d)"
        csplit -sn9 "${depends_blocks}" '/^$/' '{*}'
        find . -type f -name 'xx*' \
            -exec sed -i '/^[[:space:]]*$/d' {} + \
            -exec paste -s {} + \
            >"${adjlist}"
    )
    sed -i '/^[[:space:]]*$/d' "${adjlist}"
    sort -uo "${adjlist}" "${adjlist}"

    # From the adjacency list, create normalized list of partial orderings of
    # the following form:
    #
    #     <PKG-1>\t<DEP-1-1>
    #     <PKG-3>\t<DEP-3-1>
    #     <PKG-3>\t<DEP-3-2>
    #     ...
    #
    # Note that <PKG2> is absent because it has no dependencies.
    local partords="$(mktemp -t partords.XXXXXX)"
    while read head rest; do
        # rest is empty iff head has no dependencies; no edge needed
        echo "${rest}" | tr '\t' '\n' | xargs -rI{} printf "${head}\t{}\n"
    done <"${adjlist}" >"${partords}"
    sort -uo "${partords}" "${partords}"

    # print partial orderings
    cat "${partords}"
}

# for the given directory...
#
# * create and/or update a fake apt repository within
#
# * install a (deterministically) generated apt sources list file
#
# * update the apt configuration
#
# $1 : fake apt repository directory
apt_repolize() {
    if ! [ -n "${1:-}" ]; then
        error "bad args"
        return 1
    fi
    if ! [ -d "$1" ]; then
        error "missing directory: $1"
        return 1
    fi
    (
        cd "$1"
        dpkg-scanpackages --multiversion . >Packages
        cat >"${fake_apt_dir}/etc/apt/sources.list.d/$(echo "${PWD}" | tr -s '/' '_').list" <<EOF
deb     [trusted=yes] file://${PWD} ./
EOF
        apt-get -y update
    )
}

run_raw() {
    # make a fake apt configuration that a luser can work
    local fake_apt_dir="$(mktemp -dt fake_apt_dir.XXXXXX)"
    tar -cf- -C / etc/apt var/lib/apt var/cache/apt | tar -xf- -C "${fake_apt_dir}"
    export APT_CONFIG="${fake_apt_dir}/etc/apt/apt.conf"
    cat >"${APT_CONFIG}" <<EOF
Dir "${fake_apt_dir}";
EOF

    # create/update fake apt repo in workdir
    apt_repolize "${workdir}"

    local edges="$(mktemp -t edges.XXXXXX)"
    packages2edges "${workdir}/Packages" >"${edges}"
    (
        cd "${workdir}"
        cut -f2 "${edges}" | xargs apt-get download
    )
    apt_repolize "${workdir}"

    # TODO: FIX KOSARAJU
    packages2edges "${workdir}/Packages" >"${edges}"

    # generate the list of "strongly connected component" packages
    local scc_packages="$(mktemp -t scc_packages.XXXXXX)"
    kosaraju_scc "${edges}" >"${scc_packages}"
    sort -uo "${scc_packages}" "${scc_packages}"

    # generate the list of all packages
    local all_packages="$(mktemp -t all_packages.XXXXXX)"
    packages2names "${workdir}/Packages" >"${all_packages}"
    sort -uo "${all_packages}" "${all_packages}"

    # set-subtract from all packages the scc packages to give "weakly connected
    # component" packages; i.e., the list of packages to install
    comm -23 "${all_packages}" "${scc_packages}" >"${workdir}/install-list.txt"
}

run_dockerized() {
    readonly image_name="ubuntu:${distribution}"
    if [ "true" = "${DOCKER_IMAGE_PULL:-false}" ]; then
        docker image pull "${image_name}"
    else
        warning "skipping: docker image pull ${image_name}"
    fi

    docker container run \
        --env DEBCONF_NONINTERACTIVE_SEEN=true \
        --env DEBIAN_FRONTEND=noninteractive \
        --env DISTRIBUTION="${distribution}" \
        --env DOCKER_HOST_GID="$(id -g)" \
        --env DOCKER_HOST_UID="$(id -u)" \
        --env HERE="${here}" \
        --env THIS="${this}" \
        --env WORKDIR="${workdir}" \
        --interactive \
        --mount type=bind,readonly,source="${here}",target="${here}" \
        --mount type=bind,source="${workdir}",target="${workdir}" \
        --rm \
        --workdir "${workdir}" \
        "${image_name}" sh <<'EOF'
set -euvx
apt-get -y update
apt-get -y --no-install-recommends install dpkg-dev
"${HERE}/configure-apt" "${DISTRIBUTION}"

groupadd -g "${DOCKER_HOST_GID}" luser
useradd \
    -u "${DOCKER_HOST_UID}" \
    -g "${DOCKER_HOST_GID}" \
    -d "$(mktemp -dt home.luser.XXXXXX)" \
    -s "$(command -v sh)" \
    luser

nice -n19 su -c "${THIS} -r -C ${WORKDIR} -D ${DISTRIBUTION}" luser
EOF
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hrC:D:" opt; do
    case "${opt}" in
        h)
            usage
            exit 0
            ;;
        r) readonly run_raw="true" ;;
        C)
            if ! workdir="$(readlink -f "${OPTARG}")"; then
                die "missing: ${OPTARG}"
            fi
            if ! [ -d "${workdir}" ]; then
                die "not a directory: ${workdir}"
            fi
            readonly workdir="${workdir}"
            ;;
        D) readonly distribution="${OPTARG}" ;;
        :) die "missing argument: -${OPTARG}" ;;
        \?) die "bad option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

if [ -n "${distribution:-}" ]; then
    info "distribution: ${distribution}"
else
    readonly distribution="${default_distribution}"
    warning "defaulting distribution: ${distribution}"
fi

if [ -n "${workdir:-}" ]; then
    info "workdir: ${workdir}"
else
    readonly workdir="${PWD}"
    warning "defaulting workdir: ${workdir}"
fi

if [ "true" = "${run_raw:-false}" ]; then
    run_raw
else
    run_dockerized
fi

exit "$?"
