#!/bin/sh

# scrippies/repolizer

set -euvx

readonly this="$(readlink -f "$0")"
readonly here="$(dirname "${this}")"
readonly whatami="$(basename "${here}").$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly default_distribution="xenial"

log() { echo "${whatami}[$$]: $@" >&2; }
error() { log "ERROR: $@"; }
warning() { log "WARNING: $@"; }
info() { log "INFO: $@"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    status="$?"
    rm -rf "${tmpdir}"
    return "${status}"
}

usage() {
    cat <<EOF
Usage: $(basename ${this}) [OPTION]...
Make current working directory an apt repository with resolved dependencies.

Options:
    -h                 print this usage and return success
    -C WORKDIR         run as if started in WORKDIR
    -D DISTRIBUTION    override distribution (default: ${default_distribution})

Examples:

    \$ $(basename ${this})

    \$ $(basename ${this}) -C \$PWD

    \$ $(basename ${this}) -C \$PWD -D xenial

EOF
}

# $1 : start node
# $2 : edge list
# $3 : result list
traverse() {
    # if $1 is already a result, then return
    if grep -q "$1" "$3"; then
        return
    fi

    # look for edges starting at $1
    edges="$(mktemp -t "edges_$1.XXXXXX")"
    grep "^$1" <"$2" >"${edges}"

    # if no edges starting at $1, then add $1 to results and return
    if ! [ -s "${edges}" ]; then
        echo "$1" >>"$3"
        return
    fi

    while read curr next; do
        traverse "${next}" "$2" "$3"
    done <"${edges}"
}

# Kosaraju's algorithm for finding strongly connected components
#
# $1 : adjacency list of edges
kosaraju_scc() {
    edges="$(mktemp -t edges.XXXXXX)"
    cat >"${edges}" <"${1:-/dev/stdin}"

    # create the topological sort; save stderr to find cycles
    tsort_out="$(mktemp -t tsort_out.XXXXXX)"
    tsort_err="$(mktemp -t tsort_err.XXXXXX)"
    tsort <"${edges}" >"${tsort_out}" 2>"${tsort_err}" || true

    # remove edges that comprise cycles
    sed -nr 's|^tsort: ([[:graph:]]+)$|\1|gp' "${tsort_err}" \
        | xargs -I{} sed -i "/^{}/d" "${edges}"
    
    # transpose edges to create reverse edges
    redges="$(mktemp -t redges.XXXXXX)"
    sed -r 's|^([[:graph:]]+)([[:space:]]+)([[:graph:]]+)$|\3\2\1|g' <"${edges}" >"${redges}"
    
    # in topological order, traverse the graph of reversed edges; print every
    # dead end
    res="$(mktemp -t res.XXXXXX)"
    while read pkg; do
        traverse "${pkg}" "${redges}" "${res}";
    done <"${tsort_out}"
    sort <"${res}"
}

# given Packages file, print dependency edges
#
# $1 : Packages file
packages2edges() {
    # enumerate package names
    packages="$(mktemp -t packages.XXXXXX)"
    sed -nr 's|^Package: (.*)$|\1|gp' <"${1:-/dev/stdin}" >"${packages}"

    # enumerate recursive dependencies
    # https://stackoverflow.com/questions/22008193/how-to-list-download-the-recursive-dependencies-of-a-debian-package/41428445#41428445
    depends="$(mktemp -t depends.XXXXXX)"
    xargs apt-cache depends \
          --recurse \
          --no-recommends \
          --no-suggests \
          --no-conflicts \
          --no-breaks \
          --no-replaces \
          --no-enhances \
          --no-pre-depends \
          <"${packages}" >"${depends}"

    # > Package names (both source and binary, see Package) must consist only
    # > of lower case letters (a-z), digits (0-9), plus (+) and minus (-)
    # > signs, and periods (.). They must be at least two characters long and
    # > must start with an alphanumeric character.
    #
    # https://www.debian.org/doc/debian-policy/ch-controlfields.html#source
    sed -nri \
        -e 's/^([[:alnum:]][[:alnum:].+-]+)$/\n\1/gp' \
        -e 's/^ [ |]Depends: ([[:alnum:]][[:alnum:].+-]+)$/\1/gp' \
        "${depends}"

    # create adjacency list from apt-cache depends
    adjlist="$(mktemp -t adjlist.XXXXXX)"
    (
        cd "$(mktemp -d)"
        csplit -sn9 "${depends}" '/^$/' '{*}'
        find . -type f -name 'xx*' \
             -exec sed -i '/^[[:space:]]*$/d' {} + \
             -exec paste -s {} + \
             >"${adjlist}"
    )
    sed -i '/^[[:space:]]*$/d' "${adjlist}"
    sort -uo "${adjlist}" "${adjlist}"

    # create edges from adjacency list
    while read head rest; do
        # rest is empty iff head has no dependencies; no edge needed
        echo "${rest}" | tr '\t' '\n' | xargs -rI{} printf "${head}\t{}\n"
    done <"${adjlist}"
}

run_raw() {
    # make a fake apt configuration that a luser can work
    readonly fake_apt_dir="$(mktemp -dt fake_apt_dir.XXXXXX)"
    tar -cf- -C / etc/apt var/lib/apt var/cache/apt | tar -xf- -C "${fake_apt_dir}"
    export APT_CONFIG="${fake_apt_dir}/etc/apt/apt.conf"
    cat >"${APT_CONFIG}" <<EOF
Dir "${fake_apt_dir}";
EOF

    # make a fake apt repo in workdir
    (
        cd "${workdir}"
        dpkg-scanpackages --multiversion . >Packages
        cat >"${fake_apt_dir}/etc/apt/sources.list.d/$(echo "${PWD}" | tr -s '/' '_').list" <<EOF
deb     [trusted=yes] file://${PWD} ./
EOF
    )

    edges="$(mktemp -t edges.XXXXXX)"
    packages2edges <"${workdir}/Packages" >"${edges}"
    (
        cd "${workdir}"
        cut -f2 "${edges}" | xargs apt-get download

        # again, because we (may) have added packages
        dpkg-scanpackages --multiversion . >Packages
    )

    # TODO: FIX KOSARAJU
    return
    packages2edges <"${workdir}/Packages" >"${edges}"

    # generate the list of "strongly connected component" packages
    kosaraju_scc <"${edges}" >"${workdir}/install-list.txt"
}

run_dockerized() {
    readonly image_name="ubuntu:${distribution}"
    if [ "true" = "${DOCKER_IMAGE_PULL:-false}" ]; then
        docker image pull "${image_name}"
    else
        warning "skipping: docker image pull ${image_name}"
    fi

    docker container run \
        --env DEBCONF_NONINTERACTIVE_SEEN=true \
        --env DEBIAN_FRONTEND=noninteractive \
        --env DISTRIBUTION="${distribution}" \
        --env DOCKER_HOST_GID="$(id -g)" \
        --env DOCKER_HOST_UID="$(id -u)" \
        --env HERE="${here}" \
        --env THIS="${this}" \
        --env WORKDIR="${workdir}" \
        --interactive \
        --mount type=bind,readonly,source="${here}",target="${here}" \
        --mount type=bind,source="${workdir}",target="${workdir}" \
        --rm \
        --workdir "${workdir}" \
        "${image_name}" sh <<'EOF'
set -euvx
apt-get -y update
apt-get -y --no-install-recommends install dpkg-dev
"${HERE}/configure-apt" "${DISTRIBUTION}"

groupadd -g "${DOCKER_HOST_GID}" luser
useradd \
    -u "${DOCKER_HOST_UID}" \
    -g "${DOCKER_HOST_GID}" \
    -d "$(mktemp -dt home.luser.XXXXXX)" \
    -s "$(command -v sh)" \
    luser

nice -n19 su -c "${THIS} -r -C ${WORKDIR} -D ${DISTRIBUTION}" luser
EOF
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":hrC:D:" opt; do
    case "${opt}" in
        h)
            usage
            exit 0
            ;;
        r) readonly run_raw="true" ;;
        C)
            if ! workdir="$(readlink -f "${OPTARG}")"; then
                die "missing: ${OPTARG}"
            fi
            if ! [ -d "${workdir}" ]; then
                die "not a directory: ${workdir}"
            fi
            readonly workdir="${workdir}"
            ;;
        D) readonly distribution="${OPTARG}" ;;
        :) die "missing argument: -${OPTARG}" ;;
        \?) die "bad option: -${OPTARG}" ;;
    esac
done
shift "$((${OPTIND} - 1))"

if [ -n "${distribution:-}" ]; then
    info "distribution: ${distribution}"
else
    readonly distribution="${default_distribution}"
    warning "defaulting distribution: ${distribution}"
fi

if [ -n "${workdir:-}" ]; then
    info "workdir: ${workdir}"
else
    readonly workdir="${PWD}"
    warning "defaulting workdir: ${workdir}"
fi

if [ "true" = "${run_raw:-false}" ]; then
    run_raw
else
    run_dockerized
fi

exit "$?"
