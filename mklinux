#!/bin/sh
# shellcheck disable=SC2039

set -euvx

readonly this="$(readlink -f "$0")"
readonly whatami="$(basename "${this}")"
readonly tmpdir="$(mktemp -dt "${whatami}.XXXXXX")"

readonly cache="${PWD}/cache.d"

log() { echo "${whatami}[$$]: $*" >&2; }
error() { log "ERROR: $*"; }
warning() { log "WARNING: $*"; }
info() { log "INFO: $*"; }

die() {
    error "$@"
    usage >&2
    exit 1
}

cleanup() {
    local status="$?"
    rm -rf "${tmpdir}" || true
    if command -v docker >/dev/null 2>&1; then
        docker system prune --force --filter until=6h || true
        docker volume prune -f || true
    fi
    return "${status}"
}

usage() {
    cat <<EOF

Usage: $0 [OPTION]...
Build a linux kernel Debian package.

Options:
    -h    print this usage and return success

Examples:

    \$ $0 -h

    \$ $0

EOF
}

# $1: url
# $2: dst (default $cache/$1)
curl_cache() {
    # shellcheck disable=SC2039
    local dst="${2:-${cache}/${1}}"
    if [ -f "${cache}/${1}" ]; then
        return 0
    fi
    mkdir -p "$(dirname "${dst}")"
    curl -fsSLo "${dst}" "${1}"
}

# $1 : dir
# $2 : name
find_the_one() {
    # shellcheck disable=SC2039
    local list=""
    list="$(mktemp -t list.XXXXXX)"
    find "$1" -type f -name "$2" >"${list}"
    sort -uo "${list}" "${list}"
    case "$(wc -l <"${list}")" in
        0)
            error "$1 has $(wc -l <"${list}") $2 files"
            return 1
            ;;
        1)
            xargs <"${list}"
            return 0
            ;;
        *)
            error "$1 has $(wc -l <"${list}") $2 files: $(paste -sd, <"${list}")"
            return 1
            ;;
    esac
    return 1
}

# $1 : uri
# $2 : dest (default: $(basename "${uri}"))
curl_no_overwrite() {
    local uri="$1"
    local dest=""
    dest="${2:-$(basename "${uri}")}"
    [ -e "${dest}" ] || curl -fsSLo "${dest}" "${uri}"
}

# $1 : uri
# $2 : dest (default: $(basename "${uri}"))
curl_gpgv() {
    local uri="$1"
    local dest=""
    dest="${2:-$(basename "${uri}")}"
    curl_no_overwrite "${uri}" "${dest}"
    curl_no_overwrite "$(dirname "${uri}")/sha256sums.asc" "sha256sums.asc"
    gpg -vv --verify --trust-model=always --output=- sha256sums.asc >"sha256sums"
    sha256sum --check --ignore-missing "sha256sums"
}

# return success if $1 is newer than $2; otherwise return failure
#
# $1 : path
# $2 : path
newer_than() {
    [ -e "$1" ] && [ -e "$2" ] && [ -n "$(find -L "$1" -prune -newer "$2")" ]
}

################################################################################

trap cleanup EXIT
export TMPDIR="${tmpdir}"
export LC_ALL=C

while getopts ":h" opt; do
    case "${opt}" in
        h)
            usage
            exit 0
            ;;
        :) die "missing argument: -${OPTARG}" ;;
        \?) die "bad option: -${OPTARG}" ;;
    esac
done
shift "$((OPTIND - 1))"

readonly linux_tarxz_uri='https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.16.18.tar.xz'
readonly linux_tarxz_file="${PWD}/$(basename "${linux_tarxz_uri}")"
curl_gpgv "${linux_tarxz_uri}" "${linux_tarxz_file}"

readonly linux_tar_file="${linux_tarxz_file%.xz}"
if newer_than "${linux_tar_file}" "${linux_tarxz_file}"; then
    info "have: ${linux_tar_file}"
else
    unxz -vkf "${linux_tarxz_file}"
    touch "${linux_tar_file}"
fi

readonly linux_dir="${linux_tar_file%.tar}"
mkdir -vp "${linux_dir}" >&2
find "${linux_dir}" -mindepth 1 -delete
tar -xf "${linux_tar_file}"
touch "${linux_dir}"

readonly patch_xz_uri='https://www.kernel.org/pub/linux/kernel/projects/rt/4.16/patch-4.16.18-rt12.patch.xz'
readonly patch_xz_file="${PWD}/$(basename "${patch_xz_uri}")"
curl_gpgv "${patch_xz_uri}" "${patch_xz_file}"

readonly patch_file="${patch_xz_file%.xz}"
if newer_than "${patch_file}" "${patch_xz_file}"; then
    info "have: ${patch_file}"
else
    unxz -vkf "${patch_xz_file}"
    touch "${patch_file}"
fi

patch \
    --forward \
    --directory "${linux_dir}" \
    --reject-file - \
    --strip 1 \
    --input "${patch_file}" >&2

make -C "${linux_dir}" defconfig deb-pkg

exit "$?"
